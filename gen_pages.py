import mkdocs_gen_files
import re
from pathlib import Path, PurePosixPath
import os

# gen_pages.py adds data to command, datatype and TLO index files.
# It has to be run manually for now. python gen_pages.py

# Configuration
# OUTPUT_FILE is relative to docs_dir, will be created by mkdocs_gen_files.open()
OUTPUT_FILE = "commands/index.md"
# COMMAND_TAG_PATH_PREFIX is relative to your docs_dir, used to find command files.
# Example: "projects/macroquest/" to search within that subfolder.
# Set to "" if commands can be anywhere in docs_dir.
COMMAND_TAG_PATH_PREFIX = "projects/macroquest/"

# --- New Configuration for TLOs/DataTypes ---
TLO_DATATYPE_OUTPUT_FILE = "tlos/index.md"
# TAG_SEARCH_PATH_PREFIX will be used for TLOs/DataTypes, assuming they are in a similar base path
TAG_SEARCH_PATH_PREFIX = "projects/macroquest/"
TLO_START_MARKER = "<!-- BEGIN GENERATED TLOs -->"
TLO_END_MARKER = "<!-- END GENERATED TLOs -->"
DATATYPE_START_MARKER = "<!-- BEGIN GENERATED datatypes -->"
DATATYPE_END_MARKER = "<!-- END GENERATED datatypes -->"
SPECIAL_REFERENCE_PATH_PREFIX_FOR_SECTIONS = "projects/macroquest/reference"
SPECIAL_HEADER_TITLE_FOR_SECTIONS = "MacroQuest"
DEFAULT_TLO_SECTION_TITLE = "Other Top-Level Objects"
DEFAULT_DATATYPE_SECTION_TITLE = "Other DataTypes"

# --- Constants for generated content ---
START_MARKER = "<!-- BEGIN GENERATED COMMANDS -->"
END_MARKER = "<!-- END GENERATED COMMANDS -->"
GENERATED_COMMENT_TEMPLATE = "<!-- Content between these markers is automatically generated by {script_name}. Do not edit this section manually. -->"
DEFAULT_STATIC_HEADER = """# Command Reference

<!-- material/tags { include: [command], toc: false } -->
<style>
/* Hide tag listing but keep the page as a valid destination */
.md-typeset h2:has(.md-tag) + ul {
  display: none;
}
</style>"""

# Helper functions
def has_command_tag(content: str) -> bool:
    """Checks if the file content has a 'command' tag in its frontmatter."""
    frontmatter_match = re.search(r'^---\n(.*?)\n---', content, re.DOTALL)
    if frontmatter_match:
        frontmatter = frontmatter_match.group(1)
        # Check for tags containing "command"
        return bool(re.search(r'^tags:\s*\n\s*-\s*command\b', frontmatter, re.MULTILINE | re.IGNORECASE))
    return False

def has_tag(content: str, tag_name: str) -> bool:
    """Checks if the file content has a specific tag in its frontmatter."""
    frontmatter_match = re.search(r'^---\n(.*?)\n---', content, re.DOTALL)
    if frontmatter_match:
        frontmatter = frontmatter_match.group(1)
        # Check for tags containing the specified tag_name
        # Regex ensures it matches the whole word for the tag.
        return bool(re.search(rf'^tags:\s*\n\s*-\s*{re.escape(tag_name)}\b', frontmatter, re.MULTILINE | re.IGNORECASE))
    return False

def get_h1_from_markdown_file(file_path: Path) -> str | None:
    """Reads a markdown file and extracts the content of the first H1 header."""
    if not file_path.is_file():
        return None
    try:
        content = file_path.read_text(encoding="utf-8")
        # Regex to find the first H1 header (e.g., # Header Text)
        match = re.search(r"^\s*#\s+(.+)", content, re.MULTILINE)
        if match:
            return match.group(1).strip()
    except Exception:
        # Silently ignore errors like permission issues or encoding problems for these optional files
        pass
    return None

def get_command_page_link(file_path_relative_to_docs: str) -> str:
    """
    Generates the site-absolute link for a command page.
    Example: "projects/macroquest/cmd/foo.md" -> "/projects/macroquest/cmd/foo/"
    Example: "index.md" -> "/"
    Example: "folder/index.md" -> "/folder/"
    """
    p = PurePosixPath(file_path_relative_to_docs)
    if p.name.lower() in ("index.md", "readme.md"):
        parent_str = str(p.parent)
        if parent_str == ".": # Root index.md or readme.md
            return "/"
        return f"/{parent_str}/"
    return f"/{p.with_suffix('')}/"

def get_page_link(file_path_relative_to_docs: str) -> str:
    """
    Generates the site-absolute link for a generic page.
    Example: "projects/macroquest/tlo/foo.md" -> "/projects/macroquest/tlo/foo/"
    Example: "index.md" -> "/"
    Example: "folder/index.md" -> "/folder/"
    """
    p = PurePosixPath(file_path_relative_to_docs)
    if p.name.lower() in ("index.md", "readme.md"):
        parent_str = str(p.parent)
        if parent_str == ".": # Root index.md or readme.md
            return "/"
        return f"/{parent_str}/"
    return f"/{p.with_suffix('')}/"

# --- Core Logic Functions ---

def get_docs_dir_path() -> Path:
    """Determines the absolute path to the documentation directory."""
    try:
        # mkdocs_gen_files.editor.FilesEditor.current.directory is the absolute path to docs_dir
        docs_dir_abs_path = Path(mkdocs_gen_files.editor.FilesEditor.current.directory).resolve()
    except AttributeError:
        # Fallback if the script is run standalone or context is not fully available
        config_docs_dir = mkdocs_gen_files.config.get('docs_dir', 'docs')
        config_file_path = Path(mkdocs_gen_files.config.get('config_file_path', 'mkdocs.yml')).parent
        docs_dir_abs_path = (config_file_path / config_docs_dir).resolve()
        print(f"Warning: Using fallback for docs_dir path: {docs_dir_abs_path}")
    return docs_dir_abs_path

def find_command_files(docs_dir_abs_path: Path, command_tag_path_prefix: str) -> list[dict]:
    """
    Scans for markdown files with the 'command' tag and returns a list of entries.
    """
    command_entries = []
    exclude_specification = mkdocs_gen_files.config.get('exclude_docs')

    search_path = docs_dir_abs_path
    if command_tag_path_prefix:
        search_path = docs_dir_abs_path / command_tag_path_prefix

    glob_pattern = "**/*.md"
    print(f"Searching for command files in: {search_path} with pattern: {glob_pattern}")
    if exclude_specification:
        print(f"Applying exclusion rules from 'exclude_docs' setting.")

    for file_path_abs in search_path.glob(glob_pattern):
        path_relative_to_docs_str = str(file_path_abs.relative_to(docs_dir_abs_path).as_posix())

        is_excluded = False
        if exclude_specification and hasattr(exclude_specification, 'match_file'):
            if exclude_specification.match_file(path_relative_to_docs_str):
                is_excluded = True
        
        if is_excluded:
            continue

        try:
            content = file_path_abs.read_text(encoding="utf-8")
            if has_command_tag(content):
                command_link = get_command_page_link(path_relative_to_docs_str)
                command_entries.append({
                    "path_for_macros": path_relative_to_docs_str,
                    "link": command_link,
                })
        except Exception as e:
            print(f"Error processing file {file_path_abs}: {e}")
    
    command_entries.sort(key=lambda x: x["path_for_macros"])
    return command_entries

def find_tagged_files(docs_dir_abs_path: Path, search_path_prefix: str, tag_name: str) -> list[dict]:
    """
    Scans for markdown files with the specified tag and returns a list of entries.
    Each entry includes path, link, and H1 title.
    """
    tagged_entries = []
    exclude_specification = mkdocs_gen_files.config.get('exclude_docs')

    search_root_path = docs_dir_abs_path
    if search_path_prefix:
        search_root_path = docs_dir_abs_path / search_path_prefix

    glob_pattern = "**/*.md"
    print(f"Searching for '{tag_name}' files in: {search_root_path} with pattern: {glob_pattern}")
    if exclude_specification:
        print(f"Applying exclusion rules from 'exclude_docs' setting.")

    for file_path_abs in search_root_path.glob(glob_pattern):
        path_relative_to_docs_str = str(file_path_abs.relative_to(docs_dir_abs_path).as_posix())

        is_excluded = False
        if exclude_specification and hasattr(exclude_specification, 'match_file'):
            if exclude_specification.match_file(path_relative_to_docs_str):
                is_excluded = True
        
        if is_excluded:
            continue

        try:
            content = file_path_abs.read_text(encoding="utf-8")
            if has_tag(content, tag_name):
                page_link = get_page_link(path_relative_to_docs_str)
                h1_title = get_h1_from_markdown_file(file_path_abs)
                # Fallback for H1 title if not found
                if not h1_title:
                    h1_title = file_path_abs.stem.replace('tlo-', '').replace('datatype-', '').replace('-', ' ').replace('_', ' ').title()

                tagged_entries.append({
                    "path_for_macros": path_relative_to_docs_str, # Path from docs root for includes
                    "link": page_link,                           # Site-absolute link for navigation
                    "h1_title": h1_title,                        # H1 title of the page
                    "abs_path": file_path_abs                    # Absolute path to the file
                })
        except Exception as e:
            print(f"Error processing file {file_path_abs} for tag '{tag_name}': {e}")
    
    # Default sort by H1 title, can be overridden later if needed for section grouping
    tagged_entries.sort(key=lambda x: (x.get("h1_title") or x["path_for_macros"]))
    return tagged_entries

def generate_command_index_markdown(command_entries: list[dict], docs_dir_abs_path: Path) -> str:
    """
    Generates the markdown content for the list of commands.
    """
    if not command_entries:
        return "No command files found to index."

    list_parts = []
    current_section_title_tracker = None
    special_command_path_prefix = "projects/macroquest/reference/commands"
    special_header_title = "MacroQuest"

    for cmd in command_entries:
        cmd_path_obj = Path(cmd['path_for_macros'])
        parent_dir_relative_path = cmd_path_obj.parent

        section_title = None
        if parent_dir_relative_path.as_posix() == special_command_path_prefix:
            section_title = special_header_title
        else:
            parent_dir_abs_path = docs_dir_abs_path / parent_dir_relative_path
            readme_path = parent_dir_abs_path / "README.md"
            index_md_path = parent_dir_abs_path / "index.md"

            section_title = get_h1_from_markdown_file(readme_path)
            if not section_title:
                section_title = get_h1_from_markdown_file(index_md_path)

            if not section_title:
                parent_dir_name_str = parent_dir_relative_path.name
                if parent_dir_name_str and parent_dir_name_str != ".":
                    section_title = parent_dir_name_str.replace('-', ' ').replace('_', ' ').title()
                else:
                    section_title = "General"
        
        if section_title is None:
             section_title = "General"

        if section_title != current_section_title_tracker:
            if list_parts:
                list_parts.append("")
            list_parts.append(f"## {section_title}")
            current_section_title_tracker = section_title

        macro_path = PurePosixPath(cmd['path_for_macros']).as_posix()
        href_link = cmd['link']

        markdown_block = f"""
<a href="{href_link}">
{{%
  include-markdown "{macro_path}"
  start="<!--cmd-syntax-start-->"
  end="<!--cmd-syntax-end-->"
%}}
</a>
:    {{% 
        include-markdown "{macro_path}"
        start="<!--cmd-desc-start-->"
        end="<!--cmd-desc-end-->"
        trailing-newlines=false
     %}} {{{{ readMore('{macro_path}') }}}}
"""
        list_parts.append(markdown_block)
    return "\n".join(list_parts)

def write_command_index_file(
    output_file_path_relative: str, 
    generated_content_md: str, 
    docs_dir_abs_path: Path,
    script_name: str
):
    """
    Writes the generated markdown to the output file, creating or updating it.
    """
    output_file_abs_path = docs_dir_abs_path / output_file_path_relative
    final_output_content = ""
    
    generated_comment_str = GENERATED_COMMENT_TEMPLATE.format(script_name=script_name)
    replacement_block_str = f"{START_MARKER}\n{generated_comment_str}\n{generated_content_md.strip()}\n{END_MARKER}"
    
    marker_regex_pattern = re.compile(f"{re.escape(START_MARKER)}.*?{re.escape(END_MARKER)}", re.DOTALL)

    try:
        if output_file_abs_path.exists():
            existing_content = output_file_abs_path.read_text(encoding="utf-8")
            match = marker_regex_pattern.search(existing_content)
            if match:
                pre_block_content = existing_content[:match.start()]
                post_block_content = existing_content[match.end():]
                final_output_content = pre_block_content + replacement_block_str + post_block_content
            else:
                print(f"Warning: Markers not found in {output_file_abs_path}. The file will be overwritten with a default header and the generated command list.")
                final_output_content = DEFAULT_STATIC_HEADER + "\n\n" + replacement_block_str
        else:
            print(f"{output_file_abs_path} not found. Creating it with a default header and the generated command list.")
            final_output_content = DEFAULT_STATIC_HEADER + "\n\n" + replacement_block_str
    except IOError as e:
        print(f"Error reading {output_file_abs_path}: {e}. Creating/overwriting file with default structure.")
        final_output_content = DEFAULT_STATIC_HEADER + "\n\n" + replacement_block_str

    with mkdocs_gen_files.open(output_file_path_relative, "w", encoding="utf-8") as f:
        f.write(final_output_content)

def update_generated_section_in_file(
    output_file_path_relative: str,
    generated_content_md: str,
    start_marker: str,
    end_marker: str,
    docs_dir_abs_path: Path,
    script_name: str
) -> bool:
    """
    Updates a specific section in an existing file, defined by start and end markers.
    Returns True if successful, False otherwise.
    """
    output_file_abs_path = docs_dir_abs_path / output_file_path_relative
    
    generated_comment_str = GENERATED_COMMENT_TEMPLATE.format(script_name=script_name)
    content_to_insert = generated_content_md.strip() if generated_content_md else ""
    
    # Ensure there's a newline after the comment and before the end marker if content is not empty
    if content_to_insert:
        replacement_block_inner_content = f"{generated_comment_str}\n{content_to_insert}"
    else: # if content_to_insert is empty, just the comment
        replacement_block_inner_content = f"{generated_comment_str}"

    # Construct the full block to replace, including markers and newlines
    replacement_block_str = f"{start_marker}\n{replacement_block_inner_content}\n{end_marker}"
    
    # Regex to find the existing block, including the markers themselves
    # Using re.DOTALL so '.' matches newlines
    marker_regex_pattern = re.compile(f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL)

    if not output_file_abs_path.exists():
        print(f"Error: Output file {output_file_abs_path} does not exist. Cannot update section.")
        return False

    try:
        existing_content = output_file_abs_path.read_text(encoding="utf-8")
        match = marker_regex_pattern.search(existing_content)
        
        if match:
            pre_block_content = existing_content[:match.start()]
            post_block_content = existing_content[match.end():]
            
            final_output_content = pre_block_content + replacement_block_str + post_block_content
            
            with mkdocs_gen_files.open(output_file_path_relative, "w", encoding="utf-8") as f:
                f.write(final_output_content)
            print(f"Successfully updated section between {start_marker} and {end_marker} in {output_file_path_relative}")
            return True
        else:
            print(f"Error: Markers {start_marker} and {end_marker} not found in {output_file_abs_path}. Section not updated.")
            return False
    except IOError as e:
        print(f"Error reading or writing {output_file_abs_path}: {e}")
        return False

def _check_markers_in_content(content: str, start_marker: str, end_marker: str) -> bool:
    """Helper to check if both start and end markers are in the content."""
    return start_marker in content and end_marker in content

def generate_item_markdown_for_index(
    item_info: dict, 
    item_type: str, # "tlo" or "datatype"
    docs_dir_abs_path: Path, 
    output_file_relative_path: str # e.g., "tlos/index.md"
) -> str:
    """Generates markdown for a single TLO or DataType item for the main index."""
    macro_path = PurePosixPath(item_info['path_for_macros']).as_posix() # Path from docs root
    h1_title = item_info.get('h1_title', Path(macro_path).stem.title())

    # Calculate relative path for the link from the output file (e.g., tlos/index.md) to the item's .md page
    output_file_dir_abs = (docs_dir_abs_path / Path(output_file_relative_path).parent).resolve()
    target_file_abs = (docs_dir_abs_path / macro_path).resolve()
    try:
        relative_link_md = Path(os.path.relpath(target_file_abs, output_file_dir_abs)).as_posix()
    except ValueError: # Happens if paths are on different drives (Windows) - use site absolute path as fallback
        relative_link_md = item_info['link']


    parts = [f"### [{h1_title}]({relative_link_md})"] # H3 for the item name, linking to its page

    source_content = ""
    try:
        source_content = item_info['abs_path'].read_text(encoding="utf-8")
    except Exception as e:
        print(f"Warning: Could not read source file {item_info['abs_path']} for generating index item '{h1_title}': {e}. Sections from this file may be incomplete in the index.")

    if item_type == "tlo":
        desc_start, desc_end = "<!--tlo-desc-start-->", "<!--tlo-desc-end-->"
        if _check_markers_in_content(source_content, desc_start, desc_end):
            parts.append(f"{{% include-markdown \"{macro_path}\" start=\"{desc_start}\" end=\"{desc_end}\" trailing-newlines=false %}} {{{{ readMore('{macro_path}') }}}}")

        forms_start, forms_end = "<!--tlo-forms-start-->", "<!--tlo-forms-end-->"
        if _check_markers_in_content(source_content, forms_start, forms_end):
            parts.append(f"<h4>Forms</h4>")
            parts.append(f"{{% include-markdown \"{macro_path}\" start=\"{forms_start}\" end=\"{forms_end}\" heading-offset=1 %}}")

        linkrefs_start, linkrefs_end = "<!--tlo-linkrefs-start-->", "<!--tlo-linkrefs-end-->"
        if _check_markers_in_content(source_content, linkrefs_start, linkrefs_end):
            parts.append(f"{{% include-markdown \"{macro_path}\" start=\"{linkrefs_start}\" end=\"{linkrefs_end}\" %}}")
    elif item_type == "datatype":
        desc_start, desc_end = "<!--dt-desc-start-->", "<!--dt-desc-end-->"
        if _check_markers_in_content(source_content, desc_start, desc_end):
            parts.append(f"{{% include-markdown \"{macro_path}\" start=\"{desc_start}\" end=\"{desc_end}\" trailing-newlines=false %}} {{{{ readMore('{macro_path}') }}}}")

        members_start, members_end = "<!--dt-members-start-->", "<!--dt-members-end-->"
        if _check_markers_in_content(source_content, members_start, members_end):
            parts.append(f"<h4>Members</h4>")
            parts.append(f"{{% include-markdown \"{macro_path}\" start=\"{members_start}\" end=\"{members_end}\" heading-offset=1 %}}")

        linkrefs_start, linkrefs_end = "<!--dt-linkrefs-start-->", "<!--dt-linkrefs-end-->"
        if _check_markers_in_content(source_content, linkrefs_start, linkrefs_end):
            parts.append(f"{{% include-markdown \"{macro_path}\" start=\"{linkrefs_start}\" end=\"{linkrefs_end}\" %}}")
    
    return "\n\n".join(parts)


def generate_index_list_markdown(
    entries: list[dict],
    item_type: str, # "tlo" or "datatype"
    docs_dir_abs_path: Path,
    output_file_relative_path: str, # e.g., "tlos/index.md"
    special_ref_path_prefix: str, 
    special_ref_header_title: str,
    default_section_title_template: str # e.g., "Other {}"
) -> str:
    """Generates markdown for a list of TLOs or DataTypes, grouped by sections."""
    if not entries:
        return f"No {item_type} files found to index."

    processed_entries = []
    for item_info in entries:
        item_path_obj = Path(item_info['path_for_macros']) # Relative to docs_dir
        parent_dir_relative_path = item_path_obj.parent

        current_item_section_title = None
        # 1. Check for special reference path
        if item_path_obj.as_posix().startswith(special_ref_path_prefix + '/'):
            current_item_section_title = special_ref_header_title
        else:
            # 2. Try H1 from README.md or index.md in parent directory
            parent_dir_abs_path = docs_dir_abs_path / parent_dir_relative_path
            h1_readme = get_h1_from_markdown_file(parent_dir_abs_path / "README.md")
            h1_index = get_h1_from_markdown_file(parent_dir_abs_path / "index.md")
            current_item_section_title = h1_readme or h1_index

            # 3. If no H1, use parent directory name (with some beautification)
            if not current_item_section_title:
                path_parts = parent_dir_relative_path.parts
                title_candidate = ""
                # Try to find a meaningful directory name, e.g., a plugin name
                # Iterate backwards from the item's parent directory
                for i in range(len(path_parts) - 1, -1, -1):
                    part = path_parts[i]
                    # Avoid generic parts like 'plugins', 'projects', 'macroquest', etc.
                    # Also avoid the search path prefix itself if it's a directory name
                    search_prefix_name = Path(TAG_SEARCH_PATH_PREFIX).name if TAG_SEARCH_PATH_PREFIX else ""
                    if part.lower() not in ['plugins', 'core-plugins', 'projects', 'macroquest', 'reference', 'top-level-objects', 'data-types', search_prefix_name.lower()]:
                        title_candidate = part.replace('-', ' ').replace('_', ' ').title()
                        break
                if title_candidate:
                    current_item_section_title = title_candidate
        
        # 4. Fallback to default section title
        if not current_item_section_title:
            current_item_section_title = default_section_title_template.format(item_type.title() + 's')
            
        processed_entries.append({**item_info, 'computed_section_title': current_item_section_title})

    # Sort entries: first by computed_section_title, then by item's h1_title
    processed_entries.sort(key=lambda x: (x['computed_section_title'], x.get('h1_title', x['path_for_macros'])))

    list_parts = []
    current_section_title_tracker = None
    for entry in processed_entries:
        section_title = entry['computed_section_title']
        if section_title != current_section_title_tracker:
            if list_parts:  # Add a blank line if not the first section, for spacing
                list_parts.append("")
            list_parts.append(f"## {section_title}")  # H2 for section title
            current_section_title_tracker = section_title

        item_md = generate_item_markdown_for_index(
            entry, 
            item_type, 
            docs_dir_abs_path, 
            output_file_relative_path
        )
        list_parts.append(item_md)
    
    return "\n\n".join(list_parts)

def set_edit_path_for_generated_file(output_file_relative_path: str, script_file_path: Path):
    """Sets the 'edit_path' for the generated file in MkDocs."""
    try:
        config_file_dir = Path(mkdocs_gen_files.config['config_file_path']).parent
        script_edit_path = str(script_file_path.resolve().relative_to(config_file_dir.resolve()).as_posix())
    except Exception:
        script_edit_path = script_file_path.name
    mkdocs_gen_files.set_edit_path(output_file_relative_path, script_edit_path)

# --- Main script execution ---
def main():
    """Main function to generate the command index."""
    current_script_path = Path(__file__)
    script_name = current_script_path.name
    docs_dir_path = get_docs_dir_path()
    
    # --- Generate Command Index ---
    command_entries = find_command_files(docs_dir_path, COMMAND_TAG_PATH_PREFIX)
    generated_command_markdown = generate_command_index_markdown(command_entries, docs_dir_path)
    write_command_index_file(
        OUTPUT_FILE, 
        generated_command_markdown, 
        docs_dir_path,
        script_name
    )
    set_edit_path_for_generated_file(OUTPUT_FILE, current_script_path)
    print(f"Generated command index at: {OUTPUT_FILE}")
    if command_entries:
        print(f"Indexed {len(command_entries)} commands.")
    else:
        print("No commands were found to index based on current criteria for commands.")

    # --- Generate TLOs/DataTypes Index ---
    print(f"\nStarting TLO/DataType index generation for {TLO_DATATYPE_OUTPUT_FILE}...")

    # Generate TLOs
    tlo_entries = find_tagged_files(docs_dir_path, TAG_SEARCH_PATH_PREFIX, "tlo")
    if tlo_entries:
        print(f"Found {len(tlo_entries)} files tagged 'tlo'.")
        generated_tlo_markdown = generate_index_list_markdown(
            entries=tlo_entries,
            item_type="tlo",
            docs_dir_abs_path=docs_dir_path,
            output_file_relative_path=TLO_DATATYPE_OUTPUT_FILE,
            special_ref_path_prefix=SPECIAL_REFERENCE_PATH_PREFIX_FOR_SECTIONS,
            special_ref_header_title=SPECIAL_HEADER_TITLE_FOR_SECTIONS,
            default_section_title_template=DEFAULT_TLO_SECTION_TITLE
        )
        update_generated_section_in_file(
            TLO_DATATYPE_OUTPUT_FILE,
            generated_tlo_markdown,
            TLO_START_MARKER,
            TLO_END_MARKER,
            docs_dir_path,
            script_name
        )
    else:
        print("No files tagged 'tlo' found.")
        # Optionally write empty content or just a comment if no TLOs are found
        update_generated_section_in_file(
            TLO_DATATYPE_OUTPUT_FILE,
            "No Top-Level Objects found with the 'tlo' tag.", # Or "" for just the comment
            TLO_START_MARKER,
            TLO_END_MARKER,
            docs_dir_path,
            script_name
        )


    # Generate DataTypes
    datatype_entries = find_tagged_files(docs_dir_path, TAG_SEARCH_PATH_PREFIX, "datatype")
    if datatype_entries:
        print(f"Found {len(datatype_entries)} files tagged 'datatype'.")
        generated_datatype_markdown = generate_index_list_markdown(
            entries=datatype_entries,
            item_type="datatype",
            docs_dir_abs_path=docs_dir_path,
            output_file_relative_path=TLO_DATATYPE_OUTPUT_FILE,
            special_ref_path_prefix=SPECIAL_REFERENCE_PATH_PREFIX_FOR_SECTIONS,
            special_ref_header_title=SPECIAL_HEADER_TITLE_FOR_SECTIONS,
            default_section_title_template=DEFAULT_DATATYPE_SECTION_TITLE
        )
        update_generated_section_in_file(
            TLO_DATATYPE_OUTPUT_FILE,
            generated_datatype_markdown,
            DATATYPE_START_MARKER,
            DATATYPE_END_MARKER,
            docs_dir_path,
            script_name
        )
    else:
        print("No files tagged 'datatype' found.")
        update_generated_section_in_file(
            TLO_DATATYPE_OUTPUT_FILE,
            "No DataTypes found with the 'datatype' tag.", # Or ""
            DATATYPE_START_MARKER,
            DATATYPE_END_MARKER,
            docs_dir_path,
            script_name
        )

    # Set edit path for the TLO/DataType index file
    # Check if the file exists before setting edit path, as update_generated_section_in_file might not create it
    if (docs_dir_path / TLO_DATATYPE_OUTPUT_FILE).exists():
        set_edit_path_for_generated_file(TLO_DATATYPE_OUTPUT_FILE, current_script_path)
        print(f"TLO/DataType index generation complete for: {TLO_DATATYPE_OUTPUT_FILE}")
    else:
        print(f"Warning: {TLO_DATATYPE_OUTPUT_FILE} was not found or created, edit path not set.")


if __name__ == "__main__":
    main()